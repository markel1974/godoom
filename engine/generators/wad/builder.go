package wad

import (
	"fmt"
	"math"
	"sort"
	"strconv"

	"github.com/markel1974/godoom/engine/generators/wad/lumps"
	"github.com/markel1974/godoom/engine/model"
)

//http://www.gamers.org/dhs/helpdocs/dmsp1666.html
//http://doomwiki.org/
//https://github.com/penberg/godoom
//https://github.com/mausimus/rtdoom/blob/master/rtdoom/Projection.cpp
//https://github.com/gamescomputersplay/wad2pic/blob/main/wad2pic.py

// ScaleFactor is a constant used to scale coordinates, dimensions, or other values for calculations and transformations.
// const ScaleFactor = 15.0
const ScaleFactorFloor = 2.0
const ScaleFactorCeil = 2.0

// Builder is responsible for constructing and managing game levels, textures, and BSP trees from WAD data.
type Builder struct {
	w        *WAD
	textures map[string]bool
}

// NewBuilder creates and returns a new instance of Builder with initialized textures mapping.
func NewBuilder() *Builder {
	return &Builder{textures: make(map[string]bool)}
}

// Setup initializes the Builder with the specified WAD file and level number, returning a ConfigRoot or an error.
func (b *Builder) Setup(wadFile string, levelNumber int) (*model.ConfigRoot, error) {
	b.w = New()
	if err := b.w.Load(wadFile); err != nil {
		return nil, err
	}
	levelNames := b.w.GetLevels()
	if levelNumber-1 >= len(levelNames) {
		return nil, fmt.Errorf("level index out of bounds: %d", levelNumber)
	}

	level, err := b.w.GetLevel(levelNames[levelNumber-1])
	if err != nil {
		return nil, err
	}

	bsp := NewBsp(level)
	sectors := b.scanSubSectors(level, bsp)

	p1 := level.Things[0]

	for _, t := range level.Things {
		if t.Type == 1 {
			p1 = t
			break
		}
	}

	_, p1Sector, _ := bsp.FindSector(p1.X, p1.Y, bsp.root)
	//interX := SnapFloat(float64(p1.X) / ScaleFactor)
	//interY := SnapFloat(float64(-p1.Y) / ScaleFactor)
	p1Pos := model.XY{X: float64(p1.X), Y: float64(-p1.Y)}
	p1Angle := float64(p1.Angle)

	player := model.NewConfigPlayer(p1Pos, p1Angle, strconv.Itoa(int(p1Sector)))
	root := model.NewConfigRoot(sectors, player, nil, 8.0, true)

	return root, nil
}

// scanSubSectors generates and returns a slice of ConfigSector objects by analyzing subsectors and applying transformations.
func (b *Builder) scanSubSectors(level *Level, bsp *BSP) []*model.ConfigSector {
	// 1. Define the global perimeter of the level (Doom Coordinates)
	minX, minY, maxX, maxY := 32768.0, 32768.0, -32768.0, -32768.0
	for _, v := range level.Vertexes {
		if float64(v.XCoord) < minX {
			minX = float64(v.XCoord)
		}
		if float64(v.XCoord) > maxX {
			maxX = float64(v.XCoord)
		}
		if float64(v.YCoord) < minY {
			minY = float64(v.YCoord)
		}
		if float64(v.YCoord) > maxY {
			maxY = float64(v.YCoord)
		}
	}

	margin := 256.0
	rootBBox := Polygons{
		{X: minX - margin, Y: minY - margin},
		{X: maxX + margin, Y: minY - margin},
		{X: maxX + margin, Y: maxY + margin},
		{X: minX - margin, Y: maxY + margin},
	}

	// 2. Traverse the entire BSP tree to generate perfect polygons
	subsectorPolys := make(map[uint16]Polygons)
	if len(level.Nodes) > 0 {
		bsp.Traverse(level, uint16(len(level.Nodes)-1), rootBBox, subsectorPolys)
	}

	// 3. T-Junction elimination: Split large sides so they all match 1:1
	b.eliminateTJunctions(level, subsectorPolys)

	// 4. Convert to engine coordinate system (inverted Y and scaled)
	for ssIdx, poly := range subsectorPolys {
		var scaled Polygons
		for _, p := range poly {
			interX := SnapFloat(p.X)
			interY := SnapFloat(-p.Y)
			scaled = append(scaled, model.XY{X: interX, Y: interY})
		}
		subsectorPolys[ssIdx] = scaled
	}

	// 5. ConfigSectors creation
	numSS := len(level.SubSectors)
	miSectors := make([]*model.ConfigSector, numSS)
	for i := 0; i < numSS; i++ {
		sectorRef, _ := level.GetSectorFromSubSector(uint16(i))
		ds := level.Sectors[sectorRef]
		floor := SnapFloat(float64(ds.FloorHeight) / ScaleFactorFloor)
		ceil := SnapFloat(float64(ds.CeilingHeight) / ScaleFactorCeil)
		miSector := &model.ConfigSector{
			Id: strconv.Itoa(i), Floor: floor, Ceil: ceil, Textures: true, Tag: strconv.Itoa(int(sectorRef)),
		}

		miSector.TextureUpper = "wall2.ppm"
		miSector.TextureWall = "wall.ppm"
		miSector.TextureLower = "floor2.ppm"
		miSector.TextureCeil = "ceil.ppm"
		miSector.TextureFloor = "floor.ppm"
		miSector.TextureScaleFactor = 10.0
		miSector.Textures = true

		poly := subsectorPolys[uint16(i)]
		for j := 0; j < len(poly); j++ {
			p1 := poly[j]
			p2 := poly[(j+1)%len(poly)]
			seg := model.NewConfigSegment(miSector.Id, model.DefinitionUnknown, p1, p2)
			miSector.Segments = append(miSector.Segments, seg)
		}
		miSectors[i] = miSector
	}

	// 6. Apply Textures (from WAD) and Topological Identification
	b.applyWadAndLinks(level, miSectors)

	for _, sector := range miSectors {
		b.forceWindingOrder(sector.Segments, false)
	}

	return miSectors
}

func (b *Builder) eliminateTJunctions(level *Level, subsectorPolys map[uint16]Polygons) {
	var allVerts Polygons

	// 1. Collect vertices generated by BSP cuts
	for _, poly := range subsectorPolys {
		allVerts = append(allVerts, poly...)
	}

	// 2. FUNDAMENTAL FIX: Add physical level vertices
	for _, v := range level.Vertexes {
		interX := SnapFloat(float64(v.XCoord))
		interY := SnapFloat(float64(-v.YCoord))
		allVerts = append(allVerts, model.XY{
			X: interX,
			Y: interY,
		})
	}

	for ssIdx, poly := range subsectorPolys {
		var newPoly Polygons
		for i := 0; i < len(poly); i++ {
			p1 := poly[i]
			p2 := poly[(i+1)%len(poly)]

			var splits Polygons
			for _, v := range allVerts {
				// Alzata tolleranza a 0.5 unscaled (mezzo pixel Doom)
				if b.distPointToSegment(v, p1, p2) < 0.5 {
					dot := (v.X-p1.X)*(p2.X-p1.X) + (v.Y-p1.Y)*(p2.Y-p1.Y)
					lenSq := (p2.X-p1.X)*(p2.X-p1.X) + (p2.Y-p1.Y)*(p2.Y-p1.Y)

					if dot > 0.1 && dot < lenSq-0.1 {
						splits = append(splits, v)
					}
				}
			}

			sort.Slice(splits, func(i, j int) bool {
				return EuclideanDistance(p1, splits[i]) < EuclideanDistance(p1, splits[j])
			})

			newPoly = append(newPoly, p1)
			for _, sp := range splits {
				if EuclideanDistance(newPoly[len(newPoly)-1], sp) > 0.1 {
					newPoly = append(newPoly, sp)
				}
			}
		}
		subsectorPolys[ssIdx] = newPoly
	}
}

// applyWadAndLinks processes map sectors, assigning textures, tags, and neighbor relationships based on WAD data and BSP output.
func (b *Builder) applyWadAndLinks(level *Level, miSectors []*model.ConfigSector) {
	for i, miSector := range miSectors {
		if miSector == nil {
			continue
		}
		ss := level.SubSectors[i]

		for _, seg := range miSector.Segments {
			mid := model.XY{
				X: SnapFloat((seg.Start.X + seg.End.X) / 2.0),
				Y: SnapFloat((seg.Start.Y + seg.End.Y) / 2.0),
			}

			// Find if this side generated by the BSP is a real WAD wall
			wadSeg := b.findOverlappingWadSeg(level, mid, ss)

			// 1. Identify the neighbor
			foundNeighbor := false
			for j, otherSector := range miSectors {
				if i == j || otherSector == nil {
					continue
				}
				for _, otherSeg := range otherSector.Segments {
					// Controllo Bidirezionale con tolleranza corretta a 0.5 (unscaled)
					match1 := EuclideanDistance(seg.Start, otherSeg.End) < 0.5 && EuclideanDistance(seg.End, otherSeg.Start) < 0.5
					match2 := EuclideanDistance(seg.Start, otherSeg.Start) < 0.5 && EuclideanDistance(seg.End, otherSeg.End) < 0.5

					if match1 || match2 {
						seg.Neighbor = otherSector.Id
						foundNeighbor = true
						break
					}
				}
				if foundNeighbor {
					break
				}
			}

			// 2. Classification based on World.go and WAD
			if wadSeg != nil {
				line := level.LineDefs[wadSeg.LineDef]
				_, side := level.SegmentSideDef(wadSeg, line)

				if side != nil {
					seg.Upper = side.UpperTexture
					seg.Middle = side.MiddleTexture
					seg.Lower = side.LowerTexture
				}
				seg.Tag = strconv.Itoa(int(line.Flags))

				if line.Flags&0x0004 == 0 {
					// It is an opaque single-sided line
					seg.Kind = model.DefinitionWall // = 2
				} else if foundNeighbor {
					// It is a Two-Sided line that connects to another sector
					seg.Kind = model.DefinitionJoin // = 3
				} else {
					// Edge case: Two-Sided facing the external void
					seg.Kind = model.DefinitionWall
				}
			} else {
				// The side is NOT in the WAD. It was created by the BSP to close the space.
				if foundNeighbor {
					// Implicit internal portal
					seg.Kind = model.DefinitionJoin // = 3
					seg.Tag = "bsp_split"
				} else {
					// The side touches the outside of the map (the virtual BBox).
					seg.Kind = model.DefinitionUnknown // = 0 (Open)
					seg.Tag = "open"
				}
			}
		}
	}
}

// distPointToSegment calculates the shortest distance from a point to a line segment in 2D space.
func (b *Builder) distPointToSegment(p model.XY, v model.XY, w model.XY) float64 {
	l2 := EuclideanDistance(v, w) * EuclideanDistance(v, w)
	if l2 == 0 {
		return EuclideanDistance(p, v)
	}
	t := ((p.X-v.X)*(w.X-v.X) + (p.Y-v.Y)*(w.Y-v.Y)) / l2
	t = math.Max(0, math.Min(1, t))
	proj := model.XY{X: v.X + t*(w.X-v.X), Y: v.Y + t*(w.Y-v.Y)}
	return EuclideanDistance(p, proj)
}

// findOverlappingWadSeg searches for a WAD segment in the given subsector whose centerline is within a close distance to the specified point.
func (b *Builder) findOverlappingWadSeg(level *Level, mid model.XY, ss *lumps.SubSector) *lumps.Seg {
	for i := int16(0); i < ss.NumSegments; i++ {
		wadSeg := level.Segments[ss.StartSeg+i]
		v1 := level.Vertexes[wadSeg.VertexStart]
		v2 := level.Vertexes[wadSeg.VertexEnd]
		interX1 := SnapFloat(float64(v1.XCoord))
		interY1 := SnapFloat(float64(-v1.YCoord))
		interX2 := SnapFloat(float64(v2.XCoord))
		interY2 := SnapFloat(float64(-v2.YCoord))
		w1 := model.XY{X: interX1, Y: interY1}
		w2 := model.XY{X: interX2, Y: interY2}

		// Alzata la tolleranza a 0.5 per riconoscere le linee in unscaled coordinates
		if b.distPointToSegment(mid, w1, w2) < 0.5 {
			return wadSeg
		}
	}
	return nil
}

// forceWindingOrder modifies the orientation of a set of line segments to enforce a desired winding order.
// The desired winding order is specified by the wantClockwise parameter (true for clockwise, false for counter-clockwise).
func (b *Builder) forceWindingOrder(segments []*model.ConfigSegment, wantClockwise bool) {
	if len(segments) < 3 {
		return
	}

	// 1. Calculate signed area (Shoelace Formula)
	area := 0.0
	for _, seg := range segments {
		area += (seg.End.X - seg.Start.X) * (seg.End.Y + seg.Start.Y)
	}

	// area > 0 indicates Clockwise direction
	// area < 0 indicates Counter-Clockwise direction
	isClockwise := area > 0

	// 2. If the orientation is already the desired one, do nothing
	if isClockwise == wantClockwise {
		return
	}

	// 3. Order reversal: swap positions in the array and invert Start-End
	for i, j := 0, len(segments)-1; i < j; i, j = i+1, j-1 {
		segments[i], segments[j] = segments[j], segments[i]
	}

	// Also invert the direction of individual vectors to maintain the closed loop
	for _, seg := range segments {
		seg.Start, seg.End = seg.End, seg.Start
	}
}
